# CoroutineFlowStudy
코루틴 부터 플로우 채널 등등 연구 테스트 레포지토리 

# 왜 코루틴인가?

## - 동시성
필요성 

_1. 동시성 없이는 사용자가 불편_
 
- 세이브 아이콘, 플로피 디스크 사례 
- 옛날에는 다운로드 중에는 아무것도 할 수 없었음  
- 한글 설치의 경우 (수십장의 디스크) 하루를 다보냈어야함 
- 이 당시 동시성이라는 개념이 아예없었음 

_2. 동시성 없이는, 하드웨어 리소스도 낭비 _

- 라이젠 3900 cpu는 749070밉스 
- 밉스는 초당 100만개의 명령어를 처리할 수 있는 능력
- 초당 7천억번의 명형을 처리 할 수 있는 기회를 날림 
- 멀티 테스킹에 대한 요구 등장 

_3. 결국 합의_

- 비선점형 멀티태스킹
- 자원을 서로 나누어씀
- 단점: 누군가는 자원을 독점하고 죽어버림, 블루스크린이 누군가 다 자원을 독점해서 생기는 일  

_4. 비선점형 문제로 중재자 도입 (커널)_
- 선점형 멀티태스킹 
- 링 개념이 있음 
- 링 레벨이 낮을 수록 가장 권한이 큼 
- 링0은 보통 커널이 관리
- 링3는 어플리케이션 레벨 , 가장 권한이 없음 
- 링1,2은 거의 사용이 안됨
- 가상화 기술을을 위해 링-1도 추가됨
- 최근에는 링-1를 사용함
- 링 레벨이 (-1->3)높은곳에서 낮은곳으로 접근 가능 반대는 안됨 
- 링0는 커널, 하드웨어 드라이버 -> 시스템 종료, 인터랩트 활성화 , 비활성화, 하드웨어  

#### 코어1개에서 여러일이 가능헀던 이유?
- 일반적으로 시분할 등의 방법으로 자원을 나눔(동시성)
- 여러 프로세스를 동시성으로 나눠 싸용함
- 이 시절 부터 프로세스와 스레드 개념이 생김 
- 지금도 우리는 선점형으로도 함 

## 병렬성
 
_1. SMP와 가시성_
- 여러 프로세스가 하나의 메모리를 쓰는 모델 
- 그래서 물리적으로 여러일을 동시에 사용하는 일이 가능해짐 
- 단점: 프로그래밍 이슈 범람 
- 여러 CPU가 개별 캐쉬를 사용하게 되면서 문제 발생 (가시성 문제)
- 가시성 문제를 해결하기 위해서 락 이나 메모리 베리어 가 필요함 
- 프로세스가 복잡해지면서 가시성 문제가 더 심각해짐
- 또한 인 오더와 아웃 오더가 존재  
- 요즘은 명령 순서를 컨트롤 할 수 있는 아웃오더를 주로 써서 문제 발생가능성이 큼 

_2. 데이터를 갱신해도 문제_
- 캐시는 캐시라인의 집합 
- 캐시라인은 64,128바이트 등 연속된 사이즈로 묶여있음
- 캐시라인 통채로 한번에 교체한다. 딱 데이터 하나만 바꿀수 없음 

_3. 가짜 공유를 걱정_
- 인접한 캐시라인은 한번에 한코어에서만 접근이 가능하다.
- 그래서 두개의 코어를 쓰는 의미가 없어짐  

_4. 비동기 병렬 프로그래밍에는 함정이 많음_
- 콜백 과 Rx를 사용 
- 콜백은 콜백지옥이 심각하게 생겨버림 
- Rx는 콜백보다는 낫지만 항상 스트림을 써야함 
- Rx는 비동기를 쓰면 코드스타일이 너무 달라짐
 
#### 코루틴은 동시성이냐 비동시성에도 코드가 달라지지 않음 


## 왜 코루틴인가? 
- 코루틴은 비동기와 병렬성을 순차적으로 짤 수있게함
- 비동기와 병렬성을 스트림의 형태로 풀 수 있음
- 비동기를 순차적으로 작성하고 싶을 시  코루틴 사용 
- 플로우에서는 스트림을 사용 
